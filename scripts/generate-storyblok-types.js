#!/usr/bin/env node
const fs = require("fs");
const path = require("path");

// Load environment variables
require("dotenv").config({ path: ".env.local" });

const STORYBLOK_TOKEN = process.env.STORYBLOK_ACCESS_TOKEN;
const OUTPUT_PATH = path.join(
  __dirname,
  "../src/types/storyblok-components.ts"
);

if (!STORYBLOK_TOKEN) {
  console.error(
    "Error: STORYBLOK_ACCESS_TOKEN not found in environment variables"
  );
  process.exit(1);
}

async function fetchComponents() {
  console.log("Fetching components from Storyblok...");

  // Try the CDN endpoint first (works with preview tokens)
  let response = await fetch(
    `https://api.storyblok.com/v2/cdn/datasource_entries?datasource=components&token=${STORYBLOK_TOKEN}&version=draft`
  );

  // If that fails, try getting a sample story and extracting component info
  if (!response.ok) {
    console.log("CDN components endpoint failed, fetching from stories...");
    response = await fetch(
      `https://api.storyblok.com/v2/cdn/stories?token=${STORYBLOK_TOKEN}&version=draft&per_page=100`
    );

    if (!response.ok) {
      throw new Error(
        `Failed to fetch stories: ${response.status} ${response.statusText}`
      );
    }

    const data = await response.json();

    // Extract unique component types from stories
    const componentSet = new Set();
    const extractComponents = (content) => {
      if (!content || typeof content !== "object") return;

      if (content.component) {
        componentSet.add(content.component);
      }

      Object.values(content).forEach((value) => {
        if (Array.isArray(value)) {
          value.forEach((item) => extractComponents(item));
        } else if (typeof value === "object" && value !== null) {
          extractComponents(value);
        }
      });
    };

    data.stories.forEach((story) => extractComponents(story.content));

    // Convert to component format
    return Array.from(componentSet).map((name) => ({
      name,
      schema: {}, // We won't have schema info, but we can still generate basic types
    }));
  }

  const data = await response.json();
  return data.datasource_entries || [];
}

function mapFieldType(field) {
  const fieldTypeMap = {
    text: "string",
    textarea: "string",
    markdown: "string",
    richtext: "RichtextStoryblok",
    number: "number",
    datetime: "string",
    boolean: "boolean",
    option: "string",
    options: "string[]",
    asset: "AssetStoryblok",
    multiasset: "AssetStoryblok[]",
    bloks: "StoryblokComponent[]",
    multilink: "MultilinkStoryblok",
    custom: "any",
  };

  return fieldTypeMap[field.type] || "any";
}

function generateTypeDefinition(component) {
  const interfaceName =
    component.name
      .split("_")
      .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
      .join("") + "Storyblok";

  let fields = component.schema ? Object.entries(component.schema) : [];

  const fieldDefinitions = fields
    .map(([key, field]) => {
      const optional = !field.required ? "?" : "";
      const type = mapFieldType(field);
      return `  ${key}${optional}: ${type};`;
    })
    .join("\n");

  return `export interface ${interfaceName} extends SbBlokData {
  component: '${component.name}';
${fieldDefinitions}
  _uid: string;
  [k: string]: any;
}`;
}

function generateTypes(components) {
  const header = `// Auto-generated by storyblok-types-generator
// Do not edit manually
import { SbBlokData } from '@storyblok/react';

// Base types
export interface AssetStoryblok {
  filename: string;
  alt?: string;
  title?: string;
  focus?: string;
  name?: string;
  [k: string]: any;
}

export interface MultilinkStoryblok {
  cached_url?: string;
  linktype?: string;
  url?: string;
  target?: string;
  [k: string]: any;
}

export interface RichtextStoryblok {
  type: string;
  content?: RichtextStoryblok[];
  marks?: RichtextStoryblok[];
  attrs?: any;
  text?: string;
  [k: string]: any;
}

export type StoryblokComponent =
${components
  .map((c) => {
    const name =
      c.name
        .split("_")
        .map((p) => p.charAt(0).toUpperCase() + p.slice(1))
        .join("") + "Storyblok";
    return `  | ${name}`;
  })
  .join("\n")};

`;

  const interfaces = components
    .map((component) => generateTypeDefinition(component))
    .join("\n\n");

  return header + interfaces + "\n";
}

async function main() {
  try {
    const components = await fetchComponents();
    console.log(`Found ${components.length} components`);

    const types = generateTypes(components);

    // Ensure directory exists
    const dir = path.dirname(OUTPUT_PATH);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    // Write types file
    fs.writeFileSync(OUTPUT_PATH, types, "utf-8");
    console.log(`âœ“ Types generated successfully at ${OUTPUT_PATH}`);
    console.log("\nGenerated types for components:");
    components.forEach((c) => console.log(`  - ${c.name}`));
  } catch (error) {
    console.error("Error generating types:", error.message);
    process.exit(1);
  }
}

main();
