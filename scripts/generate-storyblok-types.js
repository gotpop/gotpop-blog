#!/usr/bin/env node
const fs = require("node:fs")
const path = require("node:path")

// Node.js 22 natively supports .env files - no dotenv needed!
// The token should be passed as an environment variable

const STORYBLOK_TOKEN = process.env.STORYBLOK_ACCESS_TOKEN
const OUTPUT_PATH = path.join(__dirname, "../src/types/storyblok-components.ts")

if (!STORYBLOK_TOKEN) {
  console.error(
    "Error: STORYBLOK_ACCESS_TOKEN not found in environment variables"
  )
  process.exit(1)
}

async function fetchComponents() {
  console.log("Fetching components from Storyblok...")

  const response = await fetch(
    `https://api.storyblok.com/v2/cdn/stories?token=${STORYBLOK_TOKEN}&version=draft&per_page=100`
  )

  if (!response.ok) {
    throw new Error(
      `Failed to fetch stories: ${response.status} ${response.statusText}`
    )
  }

  const data = await response.json()

  // Extract unique component types from stories and collect sample data
  const componentsMap = new Map()

  const extractComponents = (content) => {
    if (!content || typeof content !== "object") return

    if (content.component) {
      const componentName = content.component

      // If we haven't seen this component, or we have a better sample, store it
      if (!componentsMap.has(componentName)) {
        componentsMap.set(componentName, { ...content })
      } else {
        // Merge properties to get a more complete picture
        const existing = componentsMap.get(componentName)
        componentsMap.set(componentName, { ...existing, ...content })
      }
    }

    Object.values(content).forEach((value) => {
      if (Array.isArray(value)) {
        for (const item of value) {
          extractComponents(item)
        }
      } else if (typeof value === "object" && value !== null) {
        extractComponents(value)
      }
    })
  }

  data.stories.forEach((story) => {
    extractComponents(story.content)
  })

  // Convert to component format with inferred schema
  return Array.from(componentsMap.entries()).map(([name, sample]) => ({
    name,
    sample, // Include the actual data sample for type inference
  }))
}

function inferFieldType(value) {
  if (value === null || value === undefined) {
    return "any"
  }

  if (typeof value === "string") {
    return "string"
  }

  if (typeof value === "number") {
    return "number"
  }

  if (typeof value === "boolean") {
    return "boolean"
  }

  if (Array.isArray(value)) {
    if (value.length === 0) return "any[]"

    // Check if it's an array of bloks
    if (value[0] && typeof value[0] === "object" && value[0].component) {
      return "StoryblokComponent[]"
    }

    const firstItemType = inferFieldType(value[0])
    return `${firstItemType}[]`
  }

  if (typeof value === "object") {
    // Check for richtext structure
    if (value.type && (value.type === "doc" || value.content)) {
      return "RichtextStoryblok"
    }

    // Check for asset structure
    if (value.filename) {
      return "AssetStoryblok"
    }

    // Check for link structure
    if (value.linktype || value.cached_url) {
      return "MultilinkStoryblok"
    }

    // Check for blok structure
    if (value.component && value._uid) {
      return "StoryblokComponent"
    }

    return "any"
  }

  return "any"
}

function generateTypeDefinition(component) {
  const interfaceName = `${component.name
    .split("_")
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join("")}Storyblok`

  // Infer fields from the sample data
  const sample = component.sample || {}
  const ignoredFields = ["_uid", "_editable", "component"]

  const fields = Object.entries(sample)
    .filter(([key]) => !ignoredFields.includes(key))
    .map(([key, value]) => {
      const type = inferFieldType(value)
      // All fields are optional since we can't know which are required
      return `  ${key}?: ${type};`
    })

  const fieldDefinitions = fields.length > 0 ? `${fields.join("\n")}\n` : ""

  return `export interface ${interfaceName} extends SbBlokData {
  component: '${component.name}';
${fieldDefinitions}  _uid: string;
  [k: string]: any;
}`
}

function generateTypes(components) {
  const header = `// Auto-generated by storyblok-types-generator
// Do not edit manually
import { SbBlokData } from '@storyblok/react';

// Base types
export interface AssetStoryblok {
  filename: string;
  alt?: string;
  title?: string;
  focus?: string;
  name?: string;
  [k: string]: any;
}

export interface MultilinkStoryblok {
  cached_url?: string;
  linktype?: string;
  url?: string;
  target?: string;
  [k: string]: any;
}

export interface RichtextStoryblok {
  type: string;
  content?: RichtextStoryblok[];
  marks?: RichtextStoryblok[];
  attrs?: any;
  text?: string;
  [k: string]: any;
}

export type StoryblokComponent =
${components
  .map((c) => {
    const name = `${c.name
      .split("_")
      .map((p) => p.charAt(0).toUpperCase() + p.slice(1))
      .join("")}Storyblok`
    return `  | ${name}`
  })
  .join("\n")};

`

  const interfaces = components
    .map((component) => generateTypeDefinition(component))
    .join("\n\n")

  return `${header + interfaces}\n`
}

async function main() {
  try {
    const components = await fetchComponents()
    console.log(`Found ${components.length} components`)

    const types = generateTypes(components)

    // Ensure directory exists
    const dir = path.dirname(OUTPUT_PATH)
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true })
    }

    // Write types file
    fs.writeFileSync(OUTPUT_PATH, types, "utf-8")
    console.log(`âœ“ Types generated successfully at ${OUTPUT_PATH}`)
    console.log("\nGenerated types for components:")
    components.forEach((c) => {
      console.log(`  - ${c.name}`)
    })
  } catch (error) {
    console.error("Error generating types:", error.message)
    process.exit(1)
  }
}

main()
